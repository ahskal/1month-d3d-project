#include <iostream>
#include <string>
#include <unordered_map>

enum class ItemType {
    None,
    // 다른 아이템 유형 추가 가능
};

class Item {
protected:
    std::string ItemName;
    float Cost;

public:
    // 아이템 정보 출력 메서드
    void ShowItemInfo() const {
        std::cout << "Item Name: " << ItemName << ", Cost: " << Cost << std::endl;
    }
};

class ItemFactory {
public:
    virtual ~ItemFactory() = default;

    // 팩토리 메소드
    virtual Item* CreateItem() = 0;
};

class ItemTable {
private:
    std::unordered_map<ItemType, std::pair<std::string, float>> table;

public:
    // 아이템 테이블에 아이템 정보 추가
    void AddItemInfo(ItemType type, const std::string& name, float cost) {
        table[type] = std::make_pair(name, cost);
    }

    // 아이템 생성 메서드
    Item* CreateItem(ItemType type, ItemFactory* factory) {
        auto it = table.find(type);
        if (it != table.end()) {
            Item* newItem = factory->CreateItem();
            newItem->ItemName = it->second.first;
            newItem->Cost = it->second.second;
            return newItem;
        }
        return nullptr; // 유효하지 않은 아이템 타입인 경우
    }
};

// 구체적인 아이템 생성을 담당하는 팩토리 클래스
class ConcreteItemFactory : public ItemFactory {
public:
    // 팩토리 메소드 구현
    Item* CreateItem() override {
        return new Item(); // 기본 생성 방식, 필요에 따라 변경 가능
    }
};

int main() {
    // 아이템 테이블 생성
    ItemTable itemTable;

    // 아이템 정보 추가
    itemTable.AddItemInfo(ItemType::None, "DefaultItem", 0.0f);
    // 다른 아이템 정보 추가 가능

    // 아이템 생성을 담당하는 팩토리 선택
    ItemFactory* factory = new ConcreteItemFactory();

    // 아이템 생성
    Item* newItem = itemTable.CreateItem(ItemType::None, factory);

    // 아이템 정보 출력
    if (newItem) {
        newItem->ShowItemInfo();
        delete newItem;
    } else {
        std::cout << "Invalid item type." << std::endl;
    }

    // 메모리 정리
    delete factory;

    return 0;
}